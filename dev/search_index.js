var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"\n\nThis page lists the public API grouped by area. Each section is generated from the docstrings in the  corresponding source files. If you are looking for a specific symbol, use the index above or your  editor's search.","category":"section"},{"location":"api/#Models","page":"API","title":"Models","text":"","category":"section"},{"location":"api/#CR3BP","page":"API","title":"CR3BP","text":"","category":"section"},{"location":"api/#Utilities","page":"API","title":"Utilities","text":"","category":"section"},{"location":"api/#Solutions","page":"API","title":"Solutions","text":"","category":"section"},{"location":"api/#Measures","page":"API","title":"Measures","text":"","category":"section"},{"location":"api/#Optimization-problem-models","page":"API","title":"Optimization problem models","text":"","category":"section"},{"location":"api/#Impulsive-Multiple-Shooting","page":"API","title":"Impulsive Multiple Shooting","text":"","category":"section"},{"location":"api/#Constant-Thrust-Multiple-Shooting","page":"API","title":"Constant Thrust Multiple Shooting","text":"","category":"section"},{"location":"api/#Motion.CR3BP.build_solution-Tuple{Number, AbstractVector{<:Number}, Number, Number, Any}","page":"API","title":"Motion.CR3BP.build_solution","text":"build_solution(μ, x0, t0, tf, alg; kwargs...) -> Solution\n\nIntegrate CR3BP and return a Solution.\n\n\n\n\n\n","category":"method"},{"location":"api/#Motion.CR3BP.build_solution_const_thrust-Tuple{Number, AbstractVector{<:Number}, AbstractVector{<:Number}, Number, Number, Any}","page":"API","title":"Motion.CR3BP.build_solution_const_thrust","text":"build_solution_const_thrust(μ, x0, u0, t0, tf, alg; kwargs...) -> Solution\n\nIntegrate CR3BP with constant thrust and return a Solution.\n\n\n\n\n\n","category":"method"},{"location":"api/#Motion.CR3BP.flow-Tuple{Number, AbstractMatrix{<:Number}, AbstractVector{<:Number}, AbstractVector{<:Number}, Vararg{Any}}","page":"API","title":"Motion.CR3BP.flow","text":"flow(μ, x0, t0, tf, [alg...]; kwargs...) -> Matrix\n\nSolve a batch (ensemble) of CR3BP trajectories.\n\nInputs\n\nx0: matrix (6, M) of initial states.\nt0, tf: vectors length M of start/end times.\nalg... (optional): ODE solver algorithm and options, passed to solve.\n\n\n\n\n\n","category":"method"},{"location":"api/#Motion.CR3BP.flow-Tuple{Number, AbstractVector{<:Number}, Number, Number, Any}","page":"API","title":"Motion.CR3BP.flow","text":"flow(μ, x0, t0, tf, alg; reltol=..., abstol=..., kwargs...) -> SVector{6,T}\n\nIntegrate CR3BP and return the final state x(tf).\n\n\n\n\n\n","category":"method"},{"location":"api/#Motion.CR3BP.flow_const_thrust-Tuple{Number, AbstractVector{<:Number}, AbstractVector{<:Number}, Number, Number, Any}","page":"API","title":"Motion.CR3BP.flow_const_thrust","text":"flow_const_thrust(μ, x0, u, t0, tf, alg; \n\tmodel=:Cartesian, reltol=..., abstol=..., kwargs...) -> SVector{6,T}\n\nIntegrate CR3BP with constant thrust and return the final state x(tf).\n\nalg is the OrdinaryDiffEq algorithm (e.g. Vern9()).\n\n\n\n\n\n","category":"method"},{"location":"api/#Motion.CR3BP.make-Tuple{Number, AbstractMatrix{<:Number}, AbstractVector{<:Number}, AbstractVector{<:Number}}","page":"API","title":"Motion.CR3BP.make","text":"make(μ, x0, t0, tf) -> EnsembleProblem\n\nBuild an EnsembleProblem for CR3BP dynamics with different initial conditions and time spans.\n\nInputs\n\nμ::Number: CR3BP mass parameter.\nx0::AbstractMatrix{<:Number}: state matrix of size (6, M); each column is [x,y,z,vx,vy,vz].\nt0::AbstractVector{<:Number}: start times, length M.\ntf::AbstractVector{<:Number}: final times, length M.\n\n\n\n\n\n","category":"method"},{"location":"api/#Motion.CR3BP.make-Tuple{Number, AbstractVector{<:Number}, Number, Number}","page":"API","title":"Motion.CR3BP.make","text":"make(μ, x0, t0, tf) -> ODEProblem\n\nBuild an ODEProblem for CR3BP with parameters stored in a ComponentArray(μ=...). Promotes (μ, x0, t0, tf) to a common scalar type for consistency.\n\n\n\n\n\n","category":"method"},{"location":"api/#Motion.CR3BP.make_const_thrust-Tuple{Number, AbstractVector{<:Number}, AbstractVector{<:Number}, Number, Number}","page":"API","title":"Motion.CR3BP.make_const_thrust","text":"make_const_thrust(μ, x0, u, t0, tf; model=:Cartesian)\n\nCreate an ODEProblem for CR3BP dynamics with constant thrust acceleration.\n\nArguments\n\nμ: CR3BP parameter.\nx0: initial state (length 6): [x,y,z, vx,vy,vz].\nu: control parameters (length 3), interpreted depending on model.\nt0, tf: initial/final times.\n\nKeyword\n\nmodel::Symbol:\n:Cartesian     → u = (ax, ay, az)\n:Spherical     → u = (r, ras, dec) (RA/DEC in radians)\n:RTN           → u = (ar, at, an) (RTN components)\n:SphericalRTN  → u = (r, rtn_ras, rtn_dec) (RTN spherical angles in radians)\n\n\n\n\n\n","category":"method"},{"location":"api/#Motion.CR3BP.rhs-Union{Tuple{T}, Tuple{AbstractVector{T}, ComponentArrays.ComponentArray{var\"#s11\", N, A} where {var\"#s11\"<:Number, N, A<:AbstractArray{var\"#s11\", N}}, Number}} where T","page":"API","title":"Motion.CR3BP.rhs","text":"rhs(x, p::ComponentArray, t) -> SVector{6,T}\n\nCR3BP rotating-frame dynamics (dimensionless).\n\nState ordering: x = [px, py, pz, vx, vy, vz].\n\nParameters:\n\np.μ: mass parameter.\n\n\n\n\n\n","category":"method"},{"location":"api/#Motion.CR3BP.rhs_const_thrust-Union{Tuple{T}, Tuple{AbstractVector{T}, ComponentArrays.ComponentArray{var\"#s26\", N, A} where {var\"#s26\"<:Number, N, A<:AbstractArray{var\"#s26\", N}}, Number}} where T","page":"API","title":"Motion.CR3BP.rhs_const_thrust","text":"rhs_const_thrust(x, p, t) -> SVector{6,T}\n\nCR3BP rotating-frame dynamics with constant thrust acceleration.\n\nx is the 6D state [x,y,z, vx,vy,vz].\np is a ComponentArray with fields:\np.μ: CR3BP mass parameter\np.acc: acceleration specification\n\n\n\n\n\n","category":"method"},{"location":"api/#Motion.libration_points-Tuple{Number}","page":"API","title":"Motion.libration_points","text":"libration_points(μ::Number; tol=1e-14)\n\nReturn the five CR3BP libration points (L1–L5) for mass parameter μ, as 6-element state vectors in the rotating frame. The points are returned in order L1, L2, L3, L4, L5.\n\n\n\n\n\n","category":"method"},{"location":"api/#Motion.BatchSolution","page":"API","title":"Motion.BatchSolution","text":"BatchSolution{S, T, V}\n\nContainer for a batch of trajectory solutions.\n\nFields\n\nsol: callable solution object\nt0, tf: vectors of initial and final times\nx0, xf: matrices of initial and final states (columns correspond to trajectories)\n\n\n\n\n\n","category":"type"},{"location":"api/#Motion.SensitivitySolution","page":"API","title":"Motion.SensitivitySolution","text":"SensitivitySolution{S, N, T, V}\n\nContainer for a single trajectory solution with sensitivities.\n\nFields\n\nsol: callable solution object\nt0, tf: initial and final times\nx0, xf: initial and final states\ndx_dx0: state sensitivity w.r.t. initial state\ndx_dtf: state sensitivity w.r.t. final time\ndx_dt0: state sensitivity w.r.t. initial time\n\n\n\n\n\n","category":"type"},{"location":"api/#Motion.Solution","page":"API","title":"Motion.Solution","text":"Solution{S, N, T, V}\n\nContainer for a single trajectory solution.\n\nFields\n\nsol: callable solution object\nt0, tf: initial and final times\nx0, xf: initial and final states\n\n\n\n\n\n","category":"type"},{"location":"api/#Motion.compute_stretch","page":"API","title":"Motion.compute_stretch","text":"compute_stretch(state, t0, tf, Δs=nothing, args...; kwargs...)\n\nCompute the stretch (speed) measure over (t0, tf) by solving an ODE that evaluates stretch(state(t)). If Δs is provided, uses a callback to save only when the measure increases by Δs.\n\n\n\n\n\n","category":"function"},{"location":"api/#Motion.ImpulsiveShooting.defects-Union{Tuple{nu}, Tuple{nx}, Tuple{N}, Tuple{F}, Tuple{T}, Tuple{AbstractVector{T}, F, Val{N}, Val{nx}, Val{nu}}} where {T, F, N, nx, nu}","page":"API","title":"Motion.ImpulsiveShooting.defects","text":"defects(vars, flow, Val(N), Val(nx), Val(nu)) -> SVector{nx*(N-1),T}\n\nCompute multiple-shooting continuity defects:\n\nd_k = X_{k+1} - flow(X_k, U_k, t_k, t_{k+1}), for k=1..N-1.\n\nThe defects are returned concatenated as a single vector of length nx*(N-1).\n\nflow(x,u,t0,t1) must return a length-nx vector (preferably SVector{nx,T}).\n\n\n\n\n\n","category":"method"},{"location":"api/#Motion.ImpulsiveShooting.indexes-Union{Tuple{nu}, Tuple{nx}, Tuple{N}, Tuple{Val{N}, Val{nx}, Val{nu}}} where {N, nx, nu}","page":"API","title":"Motion.ImpulsiveShooting.indexes","text":"indexes(Val(N), Val(nx), Val(nu)) -> (it0, idt, iX, iU)\n\nReturn StaticArrays indices describing the decision-variable layout for multiple shooting.\n\nDecision vector vars layout:\n\nvars[it0]            : scalar start time t0\nvars[idt]            : (N-1) segment durations dt₁ … dt_{N-1}\nvars[vec(iX)]        : states at nodes, packed column-major as an nx×N matrix\nvars[vec(iU)]        : controls at nodes, packed column-major as a nu×N matrix\n\n\n\n\n\n","category":"method"},{"location":"api/#Motion.ImpulsiveShooting.objective-Union{Tuple{nu}, Tuple{nx}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{T}, Val{N}, Val{nx}, Val{nu}, Val{:ENERGY}}} where {T, N, nx, nu}","page":"API","title":"Motion.ImpulsiveShooting.objective","text":"objective(vars, Val(N), Val(nx), Val(nu), Val(:ENERGY)) -> T\n\nMinimum energy objective: ∑ₖ ‖uₖ‖².\n\n\n\n\n\n","category":"method"},{"location":"api/#Motion.ImpulsiveShooting.objective-Union{Tuple{nu}, Tuple{nx}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{T}, Val{N}, Val{nx}, Val{nu}, Val{:FUEL}}} where {T, N, nx, nu}","page":"API","title":"Motion.ImpulsiveShooting.objective","text":"objective(vars, Val(N), Val(nx), Val(nu), Val(:FUEL)) -> T\n\nMinimum fuel objective: ∑ₖ √(‖uₖ‖² + ϵ) (smooth approximation of ∑‖uₖ‖).\n\n\n\n\n\n","category":"method"},{"location":"api/#Motion.ImpulsiveShooting.objective-Union{Tuple{nu}, Tuple{nx}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{T}, Val{N}, Val{nx}, Val{nu}, Val{:TIME}}} where {T, N, nx, nu}","page":"API","title":"Motion.ImpulsiveShooting.objective","text":"objective(vars, Val(N), Val(nx), Val(nu), Val(:TIME)) -> T\n\nMinimum time objective: ∑ₖ dtₖ.\n\n\n\n\n\n","category":"method"},{"location":"api/#Motion.ImpulsiveShooting.variables-Union{Tuple{nu}, Tuple{nx}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{T}, Val{N}, Val{nx}, Val{nu}}} where {T, N, nx, nu}","page":"API","title":"Motion.ImpulsiveShooting.variables","text":"variables(vars, Val(N), Val(nx), Val(nu)) -> (t0, dt, X, U, t)\n\nUnpack a decision vector into structured StaticArrays:\n\nt0::T                  start time\ndt::SVector{N-1,T}      segment durations\nX::SMatrix{nx,N,T}      node states\nU::SMatrix{nu,N,T}      node controls\nt::SVector{N,T}         node times (built from t0, dt)\n\nThis function is allocation-free.\n\n\n\n\n\n","category":"method"},{"location":"api/#Motion.ConstThrustShooting.defects-Union{Tuple{nu}, Tuple{nx}, Tuple{N}, Tuple{F}, Tuple{T}, Tuple{AbstractVector{T}, F, Val{N}, Val{nx}, Val{nu}}} where {T, F, N, nx, nu}","page":"API","title":"Motion.ConstThrustShooting.defects","text":"defects(vars, flow, Val(N), Val(nx), Val(nu)) -> SVector{nx*(N-1),T}\n\nCompute multiple-shooting defects for continuous thrust:\n\nd_k = X_{k+1} - flow(X_k, U_k, t_k, t_{k+1}), for k=1..N-1.\n\nflow(x,u,t0,t1) must return a length-nx vector (preferably SVector{nx,T}).\n\n\n\n\n\n","category":"method"},{"location":"api/#Motion.ConstThrustShooting.indexes-Union{Tuple{nu}, Tuple{nx}, Tuple{N}, Tuple{Val{N}, Val{nx}, Val{nu}}} where {N, nx, nu}","page":"API","title":"Motion.ConstThrustShooting.indexes","text":"indexes(Val(N), Val(nx), Val(nu)) -> (it0, idt, iX, iU)\n\nReturn StaticArrays indices describing the decision-vector layout for continuous-thrust multiple shooting (piecewise-constant control per segment).\n\nDecision vector vars layout:\n\nvars[it0]            : scalar start time t0\nvars[idt]            : (N-1) segment durations dt₁ … dt_{N-1}\nvars[vec(iX)]        : node states, packed column-major as an nx×N matrix\nvars[vec(iU)]        : segment controls, packed column-major as a nu×(N-1) matrix\n\nControls are defined per segment k=1..N-1 and applied over [tₖ, tₖ₊₁].\n\n\n\n\n\n","category":"method"},{"location":"api/#Motion.ConstThrustShooting.objective-Union{Tuple{nu}, Tuple{nx}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{T}, Val{N}, Val{nx}, Val{nu}, Val{:ENERGY}}} where {T, N, nx, nu}","page":"API","title":"Motion.ConstThrustShooting.objective","text":"objective(vars, Val(N), Val(nx), Val(nu), Val(:ENERGY)) -> T\n\nMinimum energy continuous thrust: ∑_{k=1}^{N-1} ‖u_k‖² dt_k\n\nApproximates ∫‖u(t)‖² dt for piecewise-constant control.\n\n\n\n\n\n","category":"method"},{"location":"api/#Motion.ConstThrustShooting.objective-Union{Tuple{nu}, Tuple{nx}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{T}, Val{N}, Val{nx}, Val{nu}, Val{:FUEL}}} where {T, N, nx, nu}","page":"API","title":"Motion.ConstThrustShooting.objective","text":"objective(vars, Val(N), Val(nx), Val(nu), Val(:FUEL)) -> T\n\nMinimum fuel objective for continuous thrust (piecewise-constant per segment): ∑_{k=1}^{N-1} √(‖u_k‖² + ϵ) * dt_k\n\nSmooth approximation of ∫‖u(t)‖ dt with ϵ = T(1e-16).\n\n\n\n\n\n","category":"method"},{"location":"api/#Motion.ConstThrustShooting.objective-Union{Tuple{nu}, Tuple{nx}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{T}, Val{N}, Val{nx}, Val{nu}, Val{:TIME}}} where {T, N, nx, nu}","page":"API","title":"Motion.ConstThrustShooting.objective","text":"objective(vars, Val(N), Val(nx), Val(nu), Val(:TIME)) -> T\n\nMinimum time objective: ∑ₖ dtₖ.\n\n\n\n\n\n","category":"method"},{"location":"api/#Motion.ConstThrustShooting.variables-Union{Tuple{nu}, Tuple{nx}, Tuple{N}, Tuple{T}, Tuple{AbstractVector{T}, Val{N}, Val{nx}, Val{nu}}} where {T, N, nx, nu}","page":"API","title":"Motion.ConstThrustShooting.variables","text":"variables(vars, Val(N), Val(nx), Val(nu)) -> (t0, dt, X, U, t)\n\nUnpack decision vector into structured StaticArrays:\n\nt0::T\ndt::SVector{N-1,T}\nX::SMatrix{nx,N,T}     node states\nU::SMatrix{nu,N-1,T}   segment controls\nt::SVector{N,T}        node times\n\n\n\n\n\n","category":"method"},{"location":"#Motion.jl","page":"Home","title":"Motion.jl","text":"Motion.jl is a fast, composable, and research-friendly Julia toolbox for exploring  simplified multi-body astrodynamics models—with a workflow that stays close to the math while  still scaling to real numerical experiments.\n\nIt aims to provide a clear path from model definition → propagation → analysis → optimization,  balancing performance, ergonomics, and extensibility for research code.","category":"section"},{"location":"#What-you-can-do-with-Motion.jl","page":"Home","title":"What you can do with Motion.jl","text":"Define and simulate dynamics in common restricted models (e.g. CR3BP, ER3BP, BCR4BP)\nIntegrate trajectories with events, stitching, and reproducible numerical settings\nCompute variational dynamics (STMs) for sensitivity, targeting, and continuation workflows\nExplore geometry (libration points, manifolds, invariant structures) for mission design\nPrototype optimization setups (multiple shooting, constraints, costs)\nVisualize trajectories and phase-space diagnostics with lightweight plotting helpers","category":"section"}]
}
