# # CR3BP: Connecting L1 → L2 Manifolds with Impulsive Multiple Shooting
#
# This tutorial connects an approximate **unstable manifold arc from L1** to an approximate
# **stable manifold arc into L2** using **impulsive multiple shooting** and an NLP solved
# with `Optimization.jl` + `Ipopt`.
#
# ## Contents
# 1. CR3BP dynamics (math + code hooks)
# 2. Local (linear) manifold directions near L1/L2
# 3. Node placement via a stretch/arc-length-like measure
# 4. Impulsive multiple shooting NLP 
# 5. Solve with Ipopt
# 6. Plot the stitched trajectory
#
# ## Deps
# - `Motion`
# - `OrdinaryDiffEqVerner`
# - `Optimization`, `OptimizationIpopt`
# - `ForwardDiff`
# - `Plots`
#

using Motion
using LinearAlgebra
using OrdinaryDiffEqVerner
using Plots
using StaticArrays

using Optimization, OptimizationIpopt
using ForwardDiff

# ## Problem setup
#
# We work in nondimensional CR3BP units with mass parameter μ.
#
const μ = 0.012150584269940356

# A small plot helper: primaries + L1/L2.
function plot_xy(μ)
	lps = Motion.libration_points(μ)[1:2]
	p = plot(framestyle = :box, xlabel = "x (-)", ylabel = "y (-)", aspect_ratio = 1)
	scatter!([1-μ], [0], label = false, marker = :o, color = :grey)
	for i in eachindex(lps)
		scatter!(p, [lps[i][1]], [lps[i][2]], label = false, marker = :d, color = :red)
	end
	return p
end

# ## CR3BP dynamics (math)
#
# In the rotating frame the state is
#
# \[
# X = \begin{bmatrix} r \\ v \end{bmatrix}
# = \begin{bmatrix} x & y & z & \dot x & \dot y & \dot z \end{bmatrix}^\top \in \mathbb{R}^6,
# \]
#
# and the dynamics are
#
# \[
# \dot r = v,\qquad \dot v = \nabla U(r) + 2\,\Omega\,v,
# \]
#
# where \(U(r)\) is the effective potential and \(2\Omega v\) encodes Coriolis terms.
#
# In this tutorial the flow map is provided by:
#
# - `Motion.CR3BP.flow(μ, X, t0, t1, integrator; kwargs...)`
# - `Motion.CR3BP.build_solution(μ, X0, t0, tf, integrator; kwargs...)`
#
# Equilibria (libration points) satisfy \(f(X^\star)=0\).
#
LPs = Motion.libration_points(μ)
Lp1 = LPs[1]
Lp2 = LPs[2];

# ## Local manifold directions via linearization
#
# Let \(A = Df(X^\star)\) be the Jacobian at a libration point. Eigenpairs \((\lambda, w)\) of \(A\)
# provide local stable/unstable directions:
#
# - If \(\Re(\lambda) > 0\): unstable direction
# - If \(\Re(\lambda) < 0\): stable direction
#
# A seed trajectory can be generated by perturbing:
#
# \[
# X_0 = X^\star + \varepsilon w,
# \]
#
# then integrating forward (unstable) or backward (stable).

# ## Approximate unstable arc from L1 (forward)
tfu = 1.2π
M1 = Motion.CR3BP.jacobian(Lp1, μ)
eig1 = eigen(M1)
w_u = real(eig1.vectors[:, end])  # heuristic: take last eigenvector

x0u = Lp1 .+ 1e-3 * w_u
sol_u = Motion.CR3BP.build_solution(μ, x0u, 0.0, tfu, Vern9(); abstol = 1e-12, reltol = 1e-12);
dt_u = LinRange(0, tfu, 1000)
X_wu = reduce(hcat, sol_u.(dt_u));

# ## Approximate stable arc into L2 (backward)
tsu = -2π
M2 = Motion.CR3BP.jacobian(Lp2, μ)
eig2 = eigen(M2)
w_s = real(eig2.vectors[:, end])

x0s = Lp2 .+ 1e-2 * w_s
sol_s = Motion.CR3BP.build_solution(μ, x0s, 0.0, tsu, Vern9(); abstol = 1e-12, reltol = 1e-12)
dt_s = LinRange(0, tsu, 1000)
X_ws = reduce(hcat, sol_s.(dt_s))

p0 = plot_xy(μ)
plot!(p0, X_wu[1, :], X_wu[2, :], color = :red, style = :dot, label = "\$\\mathcal{W}_u\$ (approx)")
plot!(p0, X_ws[1, :], X_ws[2, :], color = :green, style = :dot, label = "\$\\mathcal{W}_s\$ (approx)")
p0

# ## Node placement via a stretch measure
#
# Shooting nodes should be distributed along the curve to avoid poor conditioning.
# Using a scalar “stretch” \(s(t)\) (arc-length-like) and enforcing nearly constant increments
# improves robustness:
#
# \[
# s(t_{k+1}) - s(t_k) \approx \Delta s.
# \]
#
# This tutorial uses `Motion.compute_stretch` to generate node times satisfying the above.
#

Δs = 0.1

sol_w_u = Motion.compute_stretch(sol_u, 0, tfu, Δs, Vern9())
X_wus = reduce(hcat, sol_u.(sol_w_u.t))

sol_w_s = Motion.compute_stretch(sol_s, 0, tsu, -Δs, Vern9())
X_wss = reduce(hcat, sol_s.(sol_w_s.t))

p1 = plot_xy(μ)
plot!(p1, X_wu[1, :], X_wu[2, :], color = :red, style = :dot, label = "\$\\mathcal{W}_u\$")
scatter!(p1, X_wus[1, :], X_wus[2, :], color = :black, ms = 2, label = false)
plot!(p1, X_ws[1, :], X_ws[2, :], color = :green, style = :dot, label = "\$\\mathcal{W}_s\$")
scatter!(p1, X_wss[1, :], X_wss[2, :], color = :black, ms = 2, label = false)
p1

# ## Impulsive multiple shooting formulation
#
# Choose \(N\) nodes with states \(x_k \in \mathbb{R}^{n_x}\) and impulses \(u_k \in \mathbb{R}^{n_u}\).
# A velocity impulse is injected by
#
# \[
# x_k^+ = x_k + B u_k,\qquad
# B = \begin{bmatrix} 0_{3\times 3} \\ I_{3} \end{bmatrix}.
# \]
#
# Segment propagation from node k to k+1:
#
# \[
# \Phi_k(x_k,u_k,\Delta t_k) = \varphi(\Delta t_k; x_k^+),
# \]
#
# with \(\varphi\) the CR3BP flow map.
#
# Defect constraints enforce continuity:
#
# \[
# c_k(X, U, \Delta t) = x_{k+1} - \Phi_k(x_k, u_k, \Delta t_k) = 0,
# \quad k=1,\dots,N-1.
# \]
#
# Fuel-like objective:
#
# \[
# J(U) = \sum_{k=1}^N \|u_k\|.
# \]
#
# Boundary constraints:
#
# \[
# x_1 = x_{L_1},\qquad x_N = x_{L_2}.
# \]
#
# ### Decision vector layout
#
# The decision vector is packed as:
# - `t0` (scalar)
# - `dt` (N-1)
# - `X`  (nx×N)
# - `U`  (nu×N)

t00 = 0.0

dt0 = vcat(diff(sol_w_u.t), -reverse(diff(sol_w_s.t)))
dt0[1] = 0.5
dt0[end] = 0.5

X0 = reduce(hcat, vcat(
	sol_u.(sol_w_u.t[1:(end-1)]),   # exclude last to avoid duplication
	reverse(sol_s.(sol_w_s.t)),
))

nx, N = size(X0)
nu = 3
U0 = 1e-9 * ones(nu, N)  # small impulses as initial guess

xx0 = vcat(t00, dt0, reshape(X0, nx*N), reshape(U0, nu*N))

vN  = Val(N)
vnx = Val(nx)
vnu = Val(nu);

# ## Segment flow with impulses
B = zeros(nx, nu)
B[(nx-nu+1):end, :] .= I(nu)  # add to velocity components only

flow = (x, u, t0, t1) -> begin
	x0 = x + B*u
	Motion.CR3BP.flow(μ, x0, t0, t1, Vern9(); reltol = 1e-8, abstol = 1e-8)
end;

# ## Objective + constraints (`Motion.MultipleShooting` helpers)
objective = (x, p) -> Motion.MultipleShooting.objective(x, vN, vnx, vnu, Val(:FUEL))

constraints = (out, x, p) -> begin
	out .= Motion.MultipleShooting.defects(x, flow, vN, vnx, vnu, Val(:Forward))
	nothing
end;

# ## Bounds and boundary conditions
it0, idt, iX, iU = Motion.MultipleShooting.indexes(vN, vnx, vnu)

nvars = length(xx0)
lb = fill(-Inf, nvars)
ub = fill(Inf, nvars)

# dt bounds
lb[idt] .= 1e-12
ub[idt] .= 1.0;

# fixed endpoints
lb[iX[:, 1]]   .= Lp1
ub[iX[:, 1]]   .= Lp1
lb[iX[:, end]] .= Lp2
ub[iX[:, end]] .= Lp2

# equality defects
clb = fill(0.0, nx*(N-1))
cub = fill(0.0, nx*(N-1))

# ## Create and solve the NLP

optfunc = OptimizationFunction(objective, AutoForwardDiff(); cons = constraints);

prob = OptimizationProblem(optfunc, xx0;
	lb = lb, ub = ub,
	lcons = clb, ucons = cub,
);

sol = solve(prob,
	IpoptOptimizer(
		acceptable_tol = 1e-6,
		mu_strategy = "adaptive",
		hessian_approximation = "limited-memory",
		limited_memory_max_history = 5,
        constr_viol_tol = 1e-10
	);
	maxiters = 1100,
	verbose = 3
);

# ## Plot the solution

_, _, Xo, Uo, to = Motion.MultipleShooting.variables(sol.u, vN, vnx, vnu)

p2 = plot_xy(μ)
scatter!(p2, Xo[1, :], Xo[2, :], ms = 2, label = false, color = :green)

for k in 1:(N-1)
	xk = @view Xo[:, k]
	uk = @view Uo[:, k]

	x0seg = xk + B*uk
	solseg = Motion.CR3BP.build_solution(μ, x0seg, to[k], to[k+1], Vern9(); reltol = 1e-8, abstol = 1e-8)

	τ = range(to[k], to[k+1], length = 100)
	Xseg = reduce(hcat, solseg.(τ))

	plot!(p2, Xseg[1, :], Xseg[2, :], label = false, linewidth = 0.75, color = :grey, style = :dash)
end
p2
